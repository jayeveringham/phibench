# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

PhiBench is a dual-purpose project:
1. **Python benchmark suite** - 20,100 PyPhi results across network topologies and TPM rules
2. **C++ implementation** - High-performance IIT Phi computation (Phase 1 complete, validated against PyPhi)

## Build and Test Commands

### C++ Implementation (cuda/)

```bash
# Compile and run validation tests
cd cuda
g++ -std=c++20 -O2 -I include -o test_validation tests/test_validation.cpp
./test_validation  # 24/24 tests

# Comprehensive PyPhi validation (3240 tests)
g++ -std=c++20 -O2 -I include -o test_comprehensive tests/test_pyphi_comprehensive.cpp
./test_comprehensive

# Single BigPhi test
g++ -std=c++20 -O2 -I include -o test_bigphi tests/test_bigphi.cpp
./test_bigphi
```

### Python Benchmark

```bash
source venv/bin/activate
python run_benchmark.py --config config.json --results-dir results
python analyze_results.py --export-json
```

## C++ Architecture

Header-only library in `cuda/include/phi/`:

```
phi.hpp                 # Main include - includes everything
core/types.hpp          # NodeSet (uint64_t bitmask), StateIndex, Real, Direction enum
data/tpm.hpp            # TPM class - Transition Probability Matrix (2^n x n)
data/repertoire.hpp     # Repertoire class - probability distributions with purview
partition/bipartition.hpp  # MIP/KCut partition enumeration
metrics/emd.hpp         # hamming_emd(), exact_emd_ssp() algorithms
compute/small_phi.hpp   # MIC/MIE, find_mip(), compute_concept()
compute/big_phi.hpp     # CES, SIA, compute_sia(), ces_distance_xemd()
```

### Key Types
- `NodeSet` - bitmask for node subsets (up to 64 nodes)
- `Repertoire` - probability distribution with associated purview
- `Concept` - mechanism + MIC (cause) + MIE (effect) + phi value
- `CES` - Cause-Effect Structure (collection of concepts)
- `SIA` - System Irreducibility Analysis result (BigPhi + MIP cut)

### Computation Flow
```
compute_sia(network, nodes, state)
  -> compute_ces(subsystem)           # enumerate all mechanisms
     -> compute_concept(mechanism)    # for each mechanism
        -> find_mip(CAUSE)            # find MIC
        -> find_mip(EFFECT)           # find MIE
  -> for each system cut:
     -> ces_distance_xemd()           # compare unpartitioned vs partitioned CES
  -> return minimum distance cut (MIP)
```

## Critical Implementation Details

These details were discovered during PyPhi validation and are essential for correctness:

1. **Array Ordering**: PyPhi uses big-endian state ordering, C++ uses little-endian. Use bit reversal when loading PyPhi test data.

2. **Repertoire Expansion Asymmetry**:
   - CAUSE: expand with max entropy (uniform) for new nodes
   - EFFECT: expand with unconstrained effect repertoire (NOT uniform)

3. **Null Concept Distance**:
   - Cause null = max entropy
   - Effect null = unconstrained effect repertoire (empty mechanism)

4. **Single-Node Concepts**: Do NOT early-exit when unpartitioned repertoire is uniform - partitioned may still be non-uniform.

## Validation

C++ matches PyPhi to ~2e-6 precision. Test data generated by `tests/generate_validation_data.py` using PyPhi with `MEASURE='EMD'`.
