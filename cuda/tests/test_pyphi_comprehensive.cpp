/**
 * Comprehensive validation against PyPhi test data.
 *
 * This test reads JSON test data generated by PyPhi and validates
 * each component of the C++ implementation:
 * - Cause repertoires
 * - Effect repertoires
 * - Concepts (MIC/MIE)
 * - Concept distances
 * - BigPhi (SIA)
 */

#include "phi/phi.hpp"
#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <cmath>
#include <vector>
#include <map>
#include <string>

using namespace phi;

// Simple JSON parser for our test data format
// (Using a minimal parser to avoid external dependencies)
class JsonValue {
public:
    enum Type { NUL, BOOL, NUMBER, STRING, ARRAY, OBJECT };
    Type type = NUL;
    double num_val = 0;
    bool bool_val = false;
    std::string str_val;
    std::vector<JsonValue> arr_val;
    std::map<std::string, JsonValue> obj_val;

    bool is_null() const { return type == NUL; }
    bool is_array() const { return type == ARRAY; }
    bool is_object() const { return type == OBJECT; }
    bool is_number() const { return type == NUMBER; }
    bool is_string() const { return type == STRING; }

    double as_double() const { return num_val; }
    int as_int() const { return static_cast<int>(num_val); }
    const std::string& as_string() const { return str_val; }
    const std::vector<JsonValue>& as_array() const { return arr_val; }

    const JsonValue& operator[](const std::string& key) const {
        static JsonValue null_val;
        auto it = obj_val.find(key);
        return it != obj_val.end() ? it->second : null_val;
    }

    const JsonValue& operator[](size_t idx) const {
        static JsonValue null_val;
        return idx < arr_val.size() ? arr_val[idx] : null_val;
    }

    size_t size() const {
        if (type == ARRAY) return arr_val.size();
        if (type == OBJECT) return obj_val.size();
        return 0;
    }

    bool has(const std::string& key) const {
        return obj_val.find(key) != obj_val.end();
    }
};

class JsonParser {
public:
    static JsonValue parse(const std::string& json) {
        size_t pos = 0;
        return parse_value(json, pos);
    }

private:
    static void skip_whitespace(const std::string& s, size_t& pos) {
        while (pos < s.size() && std::isspace(s[pos])) pos++;
    }

    static JsonValue parse_value(const std::string& s, size_t& pos) {
        skip_whitespace(s, pos);
        if (pos >= s.size()) return JsonValue();

        char c = s[pos];
        if (c == '{') return parse_object(s, pos);
        if (c == '[') return parse_array(s, pos);
        if (c == '"') return parse_string(s, pos);
        if (c == 't' || c == 'f') return parse_bool(s, pos);
        if (c == 'n') return parse_null(s, pos);
        if (c == '-' || std::isdigit(c)) return parse_number(s, pos);
        return JsonValue();
    }

    static JsonValue parse_object(const std::string& s, size_t& pos) {
        JsonValue val;
        val.type = JsonValue::OBJECT;
        pos++; // skip '{'
        skip_whitespace(s, pos);
        if (s[pos] == '}') { pos++; return val; }

        while (true) {
            skip_whitespace(s, pos);
            JsonValue key = parse_string(s, pos);
            skip_whitespace(s, pos);
            pos++; // skip ':'
            JsonValue value = parse_value(s, pos);
            val.obj_val[key.str_val] = value;
            skip_whitespace(s, pos);
            if (s[pos] == '}') { pos++; break; }
            pos++; // skip ','
        }
        return val;
    }

    static JsonValue parse_array(const std::string& s, size_t& pos) {
        JsonValue val;
        val.type = JsonValue::ARRAY;
        pos++; // skip '['
        skip_whitespace(s, pos);
        if (s[pos] == ']') { pos++; return val; }

        while (true) {
            val.arr_val.push_back(parse_value(s, pos));
            skip_whitespace(s, pos);
            if (s[pos] == ']') { pos++; break; }
            pos++; // skip ','
        }
        return val;
    }

    static JsonValue parse_string(const std::string& s, size_t& pos) {
        JsonValue val;
        val.type = JsonValue::STRING;
        pos++; // skip opening '"'
        while (s[pos] != '"') {
            if (s[pos] == '\\') {
                pos++;
                if (s[pos] == 'n') val.str_val += '\n';
                else if (s[pos] == 't') val.str_val += '\t';
                else val.str_val += s[pos];
            } else {
                val.str_val += s[pos];
            }
            pos++;
        }
        pos++; // skip closing '"'
        return val;
    }

    static JsonValue parse_number(const std::string& s, size_t& pos) {
        JsonValue val;
        val.type = JsonValue::NUMBER;
        size_t start = pos;
        if (s[pos] == '-') pos++;
        while (pos < s.size() && (std::isdigit(s[pos]) || s[pos] == '.' || s[pos] == 'e' || s[pos] == 'E' || s[pos] == '+' || s[pos] == '-')) {
            if ((s[pos] == '+' || s[pos] == '-') && pos > start && s[pos-1] != 'e' && s[pos-1] != 'E') break;
            pos++;
        }
        val.num_val = std::stod(s.substr(start, pos - start));
        return val;
    }

    static JsonValue parse_bool(const std::string& s, size_t& pos) {
        JsonValue val;
        val.type = JsonValue::BOOL;
        if (s.substr(pos, 4) == "true") {
            val.bool_val = true;
            pos += 4;
        } else {
            val.bool_val = false;
            pos += 5;
        }
        return val;
    }

    static JsonValue parse_null(const std::string& s, size_t& pos) {
        pos += 4;
        return JsonValue();
    }
};

// Test result tracking
struct TestResults {
    int passed = 0;
    int failed = 0;
    std::vector<std::string> failures;

    void pass() { passed++; }
    void fail(const std::string& msg) {
        failed++;
        failures.push_back(msg);
    }

    void print_summary() const {
        std::cout << "\n========================================\n";
        std::cout << "Results: " << passed << "/" << (passed + failed) << " passed\n";
        if (failed > 0) {
            std::cout << "\nFailures:\n";
            for (size_t i = 0; i < failures.size() && i < 20; i++) {
                std::cout << "  - " << failures[i] << "\n";
            }
            if (failures.size() > 20) {
                std::cout << "  ... and " << (failures.size() - 20) << " more\n";
            }
        }
        std::cout << "========================================\n";
    }
};

// Convert JSON array to NodeSet
NodeSet json_to_nodeset(const JsonValue& arr) {
    NodeSet result = 0;
    for (size_t i = 0; i < arr.size(); i++) {
        result = bits::add(result, static_cast<NodeIndex>(arr[i].as_int()));
    }
    return result;
}

// Convert JSON array to vector of doubles
std::vector<Real> json_to_reals(const JsonValue& arr) {
    std::vector<Real> result;
    for (size_t i = 0; i < arr.size(); i++) {
        result.push_back(arr[i].as_double());
    }
    return result;
}

// Reverse bits in a state index (for converting between PyPhi and our ordering)
// PyPhi uses big-endian (node 0 is MSB), we use little-endian (node 0 is LSB)
StateIndex reverse_bits(StateIndex idx, size_t num_bits) {
    StateIndex result = 0;
    for (size_t i = 0; i < num_bits; i++) {
        if (idx & (StateIndex{1} << i)) {
            result |= StateIndex{1} << (num_bits - 1 - i);
        }
    }
    return result;
}

// Convert PyPhi flat array ordering to our little-endian ordering
std::vector<Real> convert_pyphi_to_our_order(const std::vector<Real>& pyphi, size_t num_bits) {
    std::vector<Real> result(pyphi.size());
    for (size_t pyphi_idx = 0; pyphi_idx < pyphi.size(); pyphi_idx++) {
        // PyPhi index has node 0 as MSB, we have node 0 as LSB
        // So we reverse the bits to get our index
        size_t our_idx = reverse_bits(pyphi_idx, num_bits);
        result[our_idx] = pyphi[pyphi_idx];
    }
    return result;
}

// Compare repertoires (with ordering conversion)
bool compare_repertoires(const Repertoire& computed, const std::vector<Real>& expected_pyphi, Real tol = 1e-6) {
    if (computed.num_states() != expected_pyphi.size()) return false;

    // Convert PyPhi ordering to our ordering
    size_t num_bits = 0;
    size_t n = expected_pyphi.size();
    while ((size_t{1} << num_bits) < n) num_bits++;

    auto expected = convert_pyphi_to_our_order(expected_pyphi, num_bits);

    for (size_t i = 0; i < expected.size(); i++) {
        if (std::abs(computed[i] - expected[i]) > tol) return false;
    }
    return true;
}

// Build network from JSON
std::pair<TPM, ConnectivityMatrix> build_network(const JsonValue& net) {
    size_t n = net["n_nodes"].as_int();
    const auto& tpm_data = net["tpm"];
    const auto& cm_data = net["cm"];

    TPM tpm(n);
    for (StateIndex s = 0; s < state::num_states(n); s++) {
        for (NodeIndex node = 0; node < n; node++) {
            tpm(s, node) = tpm_data[s][node].as_double();
        }
    }

    ConnectivityMatrix cm(n);
    for (NodeIndex from = 0; from < n; from++) {
        for (NodeIndex to = 0; to < n; to++) {
            cm(from, to) = cm_data[from][to].as_int();
        }
    }

    return {tpm, cm};
}

// Test repertoire computation
void test_repertoires(const JsonValue& state_data, Subsystem& subsystem, TestResults& results, const std::string& prefix) {
    const auto& tests = state_data["repertoire_tests"];

    for (size_t i = 0; i < tests.size(); i++) {
        const auto& test = tests[i];
        NodeSet mech = json_to_nodeset(test["mechanism"]);
        NodeSet purv = json_to_nodeset(test["purview"]);

        // Test cause repertoire
        auto expected_cause = json_to_reals(test["cause_repertoire"]);
        auto computed_cause = subsystem.cause_repertoire(mech, purv);

        if (!compare_repertoires(computed_cause, expected_cause)) {
            std::ostringstream oss;
            oss << prefix << " cause_rep M=" << mech << " P=" << purv;
            oss << " expected[0]=" << expected_cause[0] << " got=" << computed_cause[0];
            results.fail(oss.str());
        } else {
            results.pass();
        }

        // Test effect repertoire
        auto expected_effect = json_to_reals(test["effect_repertoire"]);
        auto computed_effect = subsystem.effect_repertoire(mech, purv);

        if (!compare_repertoires(computed_effect, expected_effect)) {
            std::ostringstream oss;
            oss << prefix << " effect_rep M=" << mech << " P=" << purv;
            oss << " expected[0]=" << expected_effect[0] << " got=" << computed_effect[0];
            results.fail(oss.str());
        } else {
            results.pass();
        }
    }
}

// Test concept computation
void test_concepts(const JsonValue& state_data, Subsystem& subsystem, TestResults& results, const std::string& prefix) {
    const auto& tests = state_data["concept_tests"];

    for (size_t i = 0; i < tests.size(); i++) {
        const auto& test = tests[i];
        NodeSet mech = json_to_nodeset(test["mechanism"]);
        Real expected_phi = test["phi"].as_double();

        auto cpt = compute_concept(subsystem, mech);

        if (!cpt) {
            std::ostringstream oss;
            oss << prefix << " concept M=" << mech << " expected phi=" << expected_phi << " got null";
            results.fail(oss.str());
            continue;
        }

        Real phi_diff = std::abs(cpt->phi() - expected_phi);
        if (phi_diff > 1e-5) {
            std::ostringstream oss;
            oss << prefix << " concept M=" << mech << " phi expected=" << expected_phi << " got=" << cpt->phi();
            results.fail(oss.str());
        } else {
            results.pass();
        }

        // Check cause purview
        NodeSet expected_cause_purv = json_to_nodeset(test["cause"]["purview"]);
        if (cpt->cause.purview != expected_cause_purv) {
            std::ostringstream oss;
            oss << prefix << " concept M=" << mech << " cause_purv expected=" << expected_cause_purv << " got=" << cpt->cause.purview;
            results.fail(oss.str());
        } else {
            results.pass();
        }

        // Check effect purview
        NodeSet expected_effect_purv = json_to_nodeset(test["effect"]["purview"]);
        if (cpt->effect.purview != expected_effect_purv) {
            std::ostringstream oss;
            oss << prefix << " concept M=" << mech << " effect_purv expected=" << expected_effect_purv << " got=" << cpt->effect.purview;
            results.fail(oss.str());
        } else {
            results.pass();
        }
    }
}

// Test BigPhi (SIA)
void test_sia(const JsonValue& state_data, Network& network, NodeSet nodes, StateIndex state, TestResults& results, const std::string& prefix) {
    const auto& sia_data = state_data["sia"];

    if (sia_data.has("unreachable") || sia_data.has("error")) {
        // Skip unreachable/error states
        return;
    }

    Real expected_phi = sia_data["phi"].as_double();
    SIA computed = compute_sia(network, nodes, state);

    Real phi_diff = std::abs(computed.phi - expected_phi);
    if (phi_diff > 1e-5) {
        std::ostringstream oss;
        oss << prefix << " BigPhi expected=" << expected_phi << " got=" << computed.phi << " diff=" << phi_diff;
        results.fail(oss.str());
    } else {
        results.pass();
    }
}

int main() {
    std::cout << "Comprehensive PyPhi Validation Tests\n";
    std::cout << "====================================\n\n";
    std::cout << std::fixed << std::setprecision(6);

    // Read test data
    std::ifstream file("/home/jay/phibench/cuda/tests/pyphi_data/comprehensive_tests.json");
    if (!file) {
        std::cerr << "Failed to open test data file\n";
        return 1;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string json_str = buffer.str();

    JsonValue test_data = JsonParser::parse(json_str);

    TestResults results;

    // Process each network
    for (size_t net_idx = 0; net_idx < test_data.size(); net_idx++) {
        const auto& net = test_data[net_idx];
        std::string net_name = net["name"].as_string();
        size_t n_nodes = net["n_nodes"].as_int();

        std::cout << "Testing network: " << net_name << " (" << n_nodes << " nodes)\n";

        auto [tpm, cm] = build_network(net);
        Network network(tpm, cm);
        NodeSet all_nodes = bits::full_set(n_nodes);

        // Process each state
        const auto& states = net["states"];
        for (const auto& [state_key, state_data] : states.obj_val) {
            if (state_data.has("unreachable") || state_data.has("error")) {
                std::cout << "  State " << state_key << ": skipped (unreachable)\n";
                continue;
            }

            StateIndex state = std::stoi(state_key);
            std::string prefix = net_name + "_s" + state_key;

            Subsystem subsystem(network, all_nodes, state);

            // Test repertoires
            size_t before = results.passed + results.failed;
            test_repertoires(state_data, subsystem, results, prefix);
            size_t rep_tests = results.passed + results.failed - before;

            // Test concepts
            before = results.passed + results.failed;
            test_concepts(state_data, subsystem, results, prefix);
            size_t concept_tests = results.passed + results.failed - before;

            // Test BigPhi
            before = results.passed + results.failed;
            test_sia(state_data, network, all_nodes, state, results, prefix);
            size_t sia_tests = results.passed + results.failed - before;

            std::cout << "  State " << state_key << ": "
                      << rep_tests << " repertoire, "
                      << concept_tests << " concept, "
                      << sia_tests << " SIA tests\n";
        }
        std::cout << "\n";
    }

    results.print_summary();
    return results.failed > 0 ? 1 : 0;
}
